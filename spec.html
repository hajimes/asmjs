<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mocha Tests for Handwritten Asm.js Modules</title>
  <link href="./bower_components/mocha/mocha.css" rel="stylesheet" />
</head>
<body>
  <div id="mocha"></div>

  <script type="text/javascript" src="./bower_components/jquery/dist/jquery.min.js"></script>
  <script type="text/javascript" src="./bower_components/expect.js/index.js"></script>
  <script type="text/javascript" src="./bower_components/mocha/mocha.js"></script>
<script type="text/javascript" src="./bower_components/chai/chai.js"></script>
  <script type="text/javascript" src="./main.js"></script>

  <script>
    mocha.setup('bdd');
  </script>
  
  <script>
describe('This handwritten asm.js module', function() {  
  var expect = chai.expect;
  
  describe('implements ufmap', function() {
    var heap = {};
    var u8heap = {};
    var mod = {};

    heap = new ArrayBuffer(1 << 20);
    u8heap = new Uint8Array(heap);
    u32heap = new Uint32Array(heap);
    mod = myAsmjsModule(window, {}, heap);
    
    it('a hash map for uint32 keys and float32 values', function() {
      var p = 100;
      var tableSize = 1 << 16;
      var maxNumberOfKeys = 1000;

      mod.ufmap_create(p, tableSize, maxNumberOfKeys);
      expect(mod.ufmap_size(p)).to.equal(0);
      mod.ufmap_add(p, 50, 3.0, 1.0);

      expect(mod.ufmap_size(p)).to.equal(1);
      expect(mod.ufmap_has(p, 50)).to.equal(1);
      mod.ufmap_add(p, 58, 3.5, 1.0);
      
      expect(mod.ufmap_size(p)).to.equal(2);
      expect(mod.ufmap_get(p, 50)).to.closeTo(3.0, 0.000001);
      expect(mod.ufmap_get(p, 58)).to.closeTo(3.5, 0.000001);

      mod.ufmap_add(p, 50, 3.0, 1.0);
      expect(mod.ufmap_get(p, 50)).to.closeTo(6.0, 0.000001);
    });

    it('that ignores new entry addition if its limit is reached', function() {
      var i = 0;
      var p = 10000;
      var tableSize = 1 << 16;
      var maxNumberOfKeys = 10;

      mod.ufmap_create(p, tableSize, maxNumberOfKeys);
      
      for (i = 0; i < 10; i += 1) {
        mod.ufmap_add(p, i, 1.0, 1.0);
      }
      
      expect(mod.ufmap_size(p)).to.equal(10);
      mod.ufmap_add(p, 10, 1.0, 1.0);
      expect(mod.ufmap_size(p)).to.equal(10);
    });
  });
  
  describe('has math functions', function() {
    var heap = {};
    var u8heap = {};
    var mod = {};

    heap = new ArrayBuffer(1 << 20);
    u8heap = new Uint8Array(heap);
    u32heap = new Uint32Array(heap);
    f32heap = new Float32Array(heap);
    mod = myAsmjsModule(window, {}, heap);

    it('for calculating the maximum value in float32s', function() {
      f32heap[25] = -3.0;
      f32heap[26] = 1.0;
      f32heap[27] = 3.0;
      
      expect(mod.maxFloat32(25 << 2, 1)).to.closeTo(-3.0, 0.000001);
      expect(mod.maxFloat32(25 << 2, 2)).to.closeTo(1.0, 0.000001);
      expect(mod.maxFloat32(25 << 2, 3)).to.closeTo(3.0, 0.000001);
    });

    it('for logsumexp of float32s', function() {
      f32heap[25] = 1.0;
      expect(mod.logsumexp(25 << 2, 1)).to.closeTo(1.0, 0.000001);
      f32heap[25] = 2.0;
      expect(mod.logsumexp(25 << 2, 1)).to.closeTo(2.0, 0.000001);
      f32heap[26] = 2.0;
      expect(mod.logsumexp(25 << 2, 2)).to.closeTo(2.6931471, 0.000001);
      f32heap[25] = -10.0;
      f32heap[26] = 10.0;
      f32heap[27] = -9.0;
      expect(mod.logsumexp(25 << 2, 3)).to.closeTo(10.0, 0.000001);
    });
  });
  
  describe('handles unicode:', function() {
    var heap = {};
    var u8heap = {};
    var u16heap = {};
    var u32heap = {};
    var mod = {};

    beforeEach(function() {      
      heap = new ArrayBuffer(1 << 20);
      u8heap = new Uint8Array(heap);
      u16heap = new Uint16Array(heap);
      u32heap = new Uint32Array(heap);
      mod = myAsmjsModule(window, {}, heap);
    });
    
    // Endian dependent
    function putUtf16(str, u16heap, pos) {
      var i = 0;
      var ch = 0;
      
      for (i = 0; i < str.length; i += 1) {
        ch = str.charCodeAt(i);
        u16heap[pos >> 1] = ch;
        pos += 2;
      }
    }
        
    it('utf16-to-utf8 conversion', function() {
      var str = '';
      var inPP = 0;
      var inP = 100;
      var inEnd = 0;
      var outPP = 1000;
      var outP = 2000;
      var outEnd = 3000;
      var errorCode = 0;
      
      // ASCII conversion
      str = 'abc';
      putUtf16(str, u16heap, inP);
      u32heap[0 >> 2] = inP;
      u32heap[outPP >> 2] = outP;
      inEnd = inP + str.length * 2;
      errorCode = mod.uc_convertUtf16toUtf8(inPP, inEnd, outPP, outEnd);
      expect(errorCode).to.equal(0);
      expect(u8heap[outP]).to.equal(97);
      expect(u8heap[outP + 1]).to.equal(98);
      expect(u8heap[outP + 2]).to.equal(99);
      expect(u32heap[inPP >> 2]).to.equal(inEnd);
      expect(u32heap[outPP >> 2]).to.equal(outP + 3);

      // Multi-byte characters
      // hiragana characters occupy 2 bytes in UTF-16 and 3 bytes in UTF-8
      str = 'あいう'; // [12354, 12356, 12358] in code points
      inP = inEnd;
      inEnd = inP + str.length * 2;
      outP = u32heap[outPP >> 2];
      putUtf16(str, u16heap, inP);
      errorCode = mod.uc_convertUtf16toUtf8(inPP, inEnd, outPP, outEnd);
      expect(errorCode).to.equal(0);
      expect(u8heap.subarray(outP, outP + 3)).to.deep.equal(
        new Uint8Array([0xe3, 0x81, 0x82])
      );
      outP += 3;
      expect(u8heap.subarray(outP, outP + 3)).to.deep.equal(
        new Uint8Array([0xe3, 0x81, 0x84])
      );
      outP += 3;
      expect(u8heap.subarray(outP, outP + 3)).to.deep.equal(
        new Uint8Array([0xe3, 0x81, 0x86])
      );
      
      // TODO: add more tests
    });

    it('utf8-to-utf16 conversion', function() {
      var inPP = 0;
      var inP = 100;
      var inEnd = 0;
      var outPP = 1000;
      var outP = 2000;
      var outEnd = 3000;
      var errorCode = 0;
      
      
      u32heap[0 >> 2] = inP;
      u32heap[outPP >> 2] = outP;
      u8heap[inP] = 0xe3;
      u8heap[inP + 1] = 0x81;
      u8heap[inP + 2] = 0x82;
      inEnd = inP + 3;
      errorCode = mod.uc_convertUtf8toUtf16(inPP, inEnd, outPP, outEnd);
      expect(errorCode).to.equal(0);
      expect(u32heap[inPP >> 2]).to.equal(103);
      expect(u16heap[outP >> 1]).to.equal(12354);
      
      // TODO: add more tests
    });
  });
  
  describe('has a hash function', function() {
    var heap = {};
    var u8heap = {};
    var mod = {};

    heap = new ArrayBuffer(1 << 20);
    u8heap = new Uint8Array(heap);
    u32heap = new Uint32Array(heap);
    mod = myAsmjsModule(window, {}, heap);
    
    function putASCII(str, u8heap, pos) {
      var i = 0;
      
      for (i = 0; i < str.length; i += 1) {
        u8heap[pos + i] = (str.charCodeAt(i) & 0xff);
      }
    }
    
    it('MurmurHash3_x86_32', function() {
      // Test vectors suggested by Ian Boyd in 2015
      // See http://stackoverflow.com/a/31929528
      var i = 0;
      var str = '';
      
      expect(mod.hash(16, 0, 0)).to.equal(0);
      expect(mod.hash(16, 0, 1) >>> 0).to.equal(0x514E28B7);
      expect(mod.hash(16, 0, 0xffffffff) >>> 0).to.equal(0x81F16F39);
      u32heap[16 >> 2] = 0xffffffff;
      expect(mod.hash(16, 4, 0) >>> 0).to.equal(0x76293B50);
      u8heap[16] = 0x21;
      u8heap[17] = 0x43;
      u8heap[18] = 0x65;
      u8heap[19] = 0x87;
      expect(mod.hash(16, 4, 0) >>> 0).to.equal(0xF55B516B);
      expect(mod.hash(16, 4, 0x5082EDEE) >>> 0).to.equal(0x2362F9DE);
      u32heap[16 >> 2] = 0;
      expect(mod.hash(16, 4, 0) >>> 0).to.equal(0x2362F9DE);
      expect(mod.hash(16, 3, 0) >>> 0).to.equal(0x85F0B427);
      expect(mod.hash(16, 2, 0) >>> 0).to.equal(0x30F4C306);
      expect(mod.hash(16, 1, 0) >>> 0).to.equal(0x514E28B7);

      str = 'Hello, world!';
      putASCII(str, u8heap, 16);
      expect(mod.hash(16, str.length, 0x9747b28c) >>> 0).
        to.equal(0x24884CBA);
      
      // for UTF-8 encoding
      // TestString("ππππππππ", 0x9747b28c, 0xD58063C1);
      
      str = '';
      for (i = 0; i < 256; i += 1) {
        str += 'a';
      }
      putASCII(str, u8heap, 16);
      expect(mod.hash(16, str.length, 0x9747b28c) >>> 0).to.equal(0x37405BDC);

      str = 'abc';
      putASCII(str, u8heap, 16);
      expect(mod.hash(16, str.length, 0) >>> 0).to.equal(0xB3DD93FA);
      str = 'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq';
      putASCII(str, u8heap, 16);
      expect(mod.hash(16, str.length, 0) >>> 0).to.equal(0xEE925B90);

      str = 'The quick brown fox jumps over the lazy dog';
      putASCII(str, u8heap, 16);
      expect(mod.hash(16, str.length, 0x9747b28c) >>> 0).
        to.equal(0x2FA826CD);
      
    });
  });
});
  </script>
  
  <script>
    mocha.checkLeaks();
    mocha.run();
  </script>
</body>
</html>
